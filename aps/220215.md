# 220215



## SWEA #1954 (달팽이 숫자)



### 문제

달팽이는 1부터 N*N까지의 숫자가 시계방향으로 이루어져 있다.

다음과 같이 정수 N을 입력 받아 N크기의 달팽이를 출력하시오.



### 입력

가장 첫 줄에는 테스트 케이스의 개수 T가 주어지고, 그 아래로 각 테스트 케이스가 주어진다.

각 테스트 케이스에는 N이 주어진다.



### 출력

각 줄은 '#t'로 시작하고, 다음 줄부터 빈칸을 사이에 두고 달팽이 숫자를 출력한다.

(t는 테스트 케이스의 번호를 의미하며 1부터 시작한다.)





### 답안

```python
T = int(input())

for tc in range(1, T+1):
    N = int(input())
    arr = [[0]*N for _ in range(N)]

    # 달팽이의 방향을 조정하기 위해 dx, dy 설정
    dx = [0, 1, 0, -1]
    dy = [1, 0, -1, 0]
	
    # i 는 달팽이가 지나는 순서
    row, col = 0, 0
    idx = 0
    i = 1
	
    # i 가 N*N 배열의 마지막 칸을 벗어나면 끝
    while N*N >= i:
        # 순서대로 달팽이가 지나감
        arr[row][col] = i
        # idx 값에 따라 우->하->좌->상 순서로 지나감
        row, col = row + dx[idx], col + dy[idx]
		
        # 만약 달팽이가 벽에 부딪히거나, 이미 지났던 칸이면,
        if not(N > row >= 0) or not(N > col >= 0) or arr[row][col] != 0:
            # 부딪히기 직전으로!
            row, col = row - dx[idx], col - dy[idx]
            # 방향을 틀자!
            idx += 1
			
            # 만약 순서를 전부 돌아 상 다음이면, idx = 0 부터 다시 시작
            if idx == 4:
                idx = 0
                row, col = row + dx[idx], col + dy[idx]
            # 아직 순서를 전부 돌기전이면, 튼 방향으로 다시 지나다니자!
            else:
                row, col = row + dx[idx], col + dy[idx]
                
		# 달팽이가 한 칸 지날때마다 i += 1
        i += 1

    print(f'#{tc}')
    for i in arr:
        ans = ' '.join(map(str, i))
        print(ans)
```





### 후기

전날에 2시간 삽질하고, 오늘 다른 사람 풀이를 참고해서 겨우 풀었다. 델타를 이용해 달팽이의 방향을 변경할 수 있고, 변경하는 순간은 조건식으로 정리해야한다.

방향 변경 조건은 달팽이가 벽에 부딪히거나(인덱스 범위 초과) 이미 지난 행 또는 열로 재진입하려는 순간이다. 만약 조건문에 진입하게 되면 직전 행과 열 인덱스로 초기화하고, 방향을 틀어준 다음 (인덱스 값 변화) 진행하면 된다.

while 문으로 달팽이가 N*N의 마지막 칸을 벗어나기 전까지 무한 반복 